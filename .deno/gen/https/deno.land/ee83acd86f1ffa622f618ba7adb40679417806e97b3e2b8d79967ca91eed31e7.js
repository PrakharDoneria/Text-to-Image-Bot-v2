import { baseFetchConfig, debug as d } from "../platform.deno.ts";
import { toGrammyError, toHttpError } from "./error.ts";
import { createFormDataPayload, createJsonPayload, requiresFormDataUpload } from "./payload.ts";
const debug = d("grammy:core");
// Transformer base functions
function concatTransformer(prev, trans) {
    return (method, payload, signal)=>trans(prev, method, payload, signal);
}
class ApiClient {
    token;
    webhookReplyEnvelope;
    options;
    hasUsedWebhookReply;
    installedTransformers;
    constructor(token, options = {}, webhookReplyEnvelope = {}){
        this.token = token;
        this.webhookReplyEnvelope = webhookReplyEnvelope;
        this.hasUsedWebhookReply = false;
        this.installedTransformers = [];
        this.call = async (method, p, signal)=>{
            const payload = p ?? {};
            debug(`Calling ${method}`);
            if (signal !== undefined) validateSignal(method, payload, signal);
            // General config
            const opts = this.options;
            const formDataRequired = requiresFormDataUpload(payload);
            // Short-circuit on webhook reply
            if (this.webhookReplyEnvelope.send !== undefined && !this.hasUsedWebhookReply && !formDataRequired && opts.canUseWebhookReply(method)) {
                this.hasUsedWebhookReply = true;
                const config = createJsonPayload({
                    ...payload,
                    method
                });
                await this.webhookReplyEnvelope.send(config.body);
                return {
                    ok: true,
                    result: true
                };
            }
            // Handle timeouts and errors in the underlying form-data stream
            const controller = createAbortControllerFromSignal(signal);
            const timeout = createTimeout(controller, opts.timeoutSeconds, method);
            const streamErr = createStreamError(controller);
            // Build request URL and config
            const url = opts.buildUrl(opts.apiRoot, this.token, method, opts.environment);
            const config = formDataRequired ? createFormDataPayload(payload, (err)=>streamErr.catch(err)) : createJsonPayload(payload);
            const sig = controller.signal;
            const options = {
                ...opts.baseFetchConfig,
                signal: sig,
                ...config
            };
            // Perform fetch call, and handle networking errors
            const successPromise = fetch(url instanceof URL ? url.href : url, options).catch(toHttpError(method, opts.sensitiveLogs));
            // Those are the three possible outcomes of the fetch call:
            const operations = [
                successPromise,
                streamErr.promise,
                timeout.promise
            ];
            // Wait for result
            try {
                const res = await Promise.race(operations);
                return await res.json();
            } finally{
                if (timeout.handle !== undefined) clearTimeout(timeout.handle);
            }
        };
        const apiRoot = options.apiRoot ?? "https://api.telegram.org";
        const environment = options.environment ?? "prod";
        this.options = {
            apiRoot,
            environment,
            buildUrl: options.buildUrl ?? defaultBuildUrl,
            timeoutSeconds: options.timeoutSeconds ?? 500,
            baseFetchConfig: {
                ...baseFetchConfig(apiRoot),
                ...options.baseFetchConfig
            },
            canUseWebhookReply: options.canUseWebhookReply ?? (()=>false),
            sensitiveLogs: options.sensitiveLogs ?? false
        };
        if (this.options.apiRoot.endsWith("/")) {
            throw new Error(`Remove the trailing '/' from the 'apiRoot' option (use '${this.options.apiRoot.substring(0, this.options.apiRoot.length - 1)}' instead of '${this.options.apiRoot}')`);
        }
    }
    call;
    use(...transformers) {
        this.call = transformers.reduce(concatTransformer, this.call);
        this.installedTransformers.push(...transformers);
        return this;
    }
    async callApi(method, payload, signal) {
        const data = await this.call(method, payload, signal);
        if (data.ok) return data.result;
        else throw toGrammyError(data, method, payload);
    }
}
/**
 * Creates a new transformable API, i.e. an object that lets you perform raw API
 * calls to the Telegram Bot API server but pass the calls through a stack of
 * transformers before. This will create a new API client instance under the
 * hood that will be used to connect to the Telegram servers. You therefore need
 * to pass the bot token. In addition, you may pass API client options as well
 * as a webhook reply envelope that allows the client to perform up to one HTTP
 * request in response to a webhook call if this is desired.
 *
 * @param token The bot's token
 * @param options A number of options to pass to the created API client
 * @param webhookReplyEnvelope The webhook reply envelope that will be used
 */ export function createRawApi(token, options, webhookReplyEnvelope) {
    const client = new ApiClient(token, options, webhookReplyEnvelope);
    const proxyHandler = {
        get (_, m) {
            return m === "toJSON" ? "__internal" : client.callApi.bind(client, m);
        },
        ...proxyMethods
    };
    const raw = new Proxy({}, proxyHandler);
    const installedTransformers = client.installedTransformers;
    const api = {
        raw,
        installedTransformers,
        use: (...t)=>{
            client.use(...t);
            return api;
        }
    };
    return api;
}
const defaultBuildUrl = (root, token, method, env)=>{
    const prefix = env === "test" ? "test/" : "";
    return `${root}/bot${token}/${prefix}${method}`;
};
const proxyMethods = {
    set () {
        return false;
    },
    defineProperty () {
        return false;
    },
    deleteProperty () {
        return false;
    },
    ownKeys () {
        return [];
    }
};
/** Creates a timeout error which aborts a given controller */ function createTimeout(controller, seconds, method) {
    let handle = undefined;
    const promise = new Promise((_, reject)=>{
        handle = setTimeout(()=>{
            const msg = `Request to '${method}' timed out after ${seconds} seconds`;
            reject(new Error(msg));
            controller.abort();
        }, 1000 * seconds);
    });
    return {
        promise,
        handle
    };
}
/** Creates a stream error which abort a given controller */ function createStreamError(abortController) {
    let onError = (err)=>{
        // Re-throw by default, but will be overwritten immediately
        throw err;
    };
    const promise = new Promise((_, reject)=>{
        onError = (err)=>{
            reject(err);
            abortController.abort();
        };
    });
    return {
        promise,
        catch: onError
    };
}
function createAbortControllerFromSignal(signal) {
    const abortController = new AbortController();
    if (signal === undefined) return abortController;
    const sig = signal;
    function abort() {
        abortController.abort();
        sig.removeEventListener("abort", abort);
    }
    if (sig.aborted) abort();
    else sig.addEventListener("abort", abort);
    return {
        abort,
        signal: abortController.signal
    };
}
function validateSignal(method, payload, signal) {
    // We use a very simple heuristic to check for AbortSignal instances
    // in order to avoid doing a runtime-specific version of `instanceof`.
    if (typeof signal?.addEventListener === "function") {
        return;
    }
    let payload0 = JSON.stringify(payload);
    if (payload0.length > 20) {
        payload0 = payload0.substring(0, 16) + " ...";
    }
    let payload1 = JSON.stringify(signal);
    if (payload1.length > 20) {
        payload1 = payload1.substring(0, 16) + " ...";
    }
    throw new Error(`Incorrect abort signal instance found! \
You passed two payloads to '${method}' but you should merge \
the second one containing '${payload1}' into the first one \
containing '${payload0}'! If you are using context shortcuts, \
you may want to use a method on 'ctx.api' instead.

If you want to prevent such mistakes in the future, \
consider using TypeScript. https://www.typescriptlang.org/`);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3gvZ3JhbW15QHYxLjI3LjAvY29yZS9jbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmFzZUZldGNoQ29uZmlnLCBkZWJ1ZyBhcyBkIH0gZnJvbSBcIi4uL3BsYXRmb3JtLmRlbm8udHNcIjtcbmltcG9ydCB7XG4gICAgdHlwZSBBcGlNZXRob2RzIGFzIFRlbGVncmFtLFxuICAgIHR5cGUgQXBpUmVzcG9uc2UsXG4gICAgdHlwZSBPcHRzLFxufSBmcm9tIFwiLi4vdHlwZXMudHNcIjtcbmltcG9ydCB7IHRvR3JhbW15RXJyb3IsIHRvSHR0cEVycm9yIH0gZnJvbSBcIi4vZXJyb3IudHNcIjtcbmltcG9ydCB7XG4gICAgY3JlYXRlRm9ybURhdGFQYXlsb2FkLFxuICAgIGNyZWF0ZUpzb25QYXlsb2FkLFxuICAgIHJlcXVpcmVzRm9ybURhdGFVcGxvYWQsXG59IGZyb20gXCIuL3BheWxvYWQudHNcIjtcbmNvbnN0IGRlYnVnID0gZChcImdyYW1teTpjb3JlXCIpO1xuXG5leHBvcnQgdHlwZSBNZXRob2RzPFIgZXh0ZW5kcyBSYXdBcGk+ID0gc3RyaW5nICYga2V5b2YgUjtcblxuLy8gQXZhaWxhYmxlIHVuZGVyIGBib3QuYXBpLnJhd2Bcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcmF3IFRlbGVncmFtIEJvdCBBUEkgd2l0aCBhbGwgbWV0aG9kcyBzcGVjaWZpZWQgMToxIGFzXG4gKiBkb2N1bWVudGVkIG9uIHRoZSB3ZWJzaXRlIChodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvYXBpKS5cbiAqXG4gKiBFdmVyeSBtZXRob2QgdGFrZXMgYW4gb3B0aW9uYWwgYEFib3J0U2lnbmFsYCBvYmplY3QgdGhhdCBhbGxvd3MgdG8gY2FuY2VsIHRoZVxuICogQVBJIGNhbGwgaWYgZGVzaXJlZC5cbiAqL1xuZXhwb3J0IHR5cGUgUmF3QXBpID0ge1xuICAgIFtNIGluIGtleW9mIFRlbGVncmFtXTogUGFyYW1ldGVyczxUZWxlZ3JhbVtNXT5bMF0gZXh0ZW5kcyB1bmRlZmluZWRcbiAgICAgICAgPyAoc2lnbmFsPzogQWJvcnRTaWduYWwpID0+IFByb21pc2U8UmV0dXJuVHlwZTxUZWxlZ3JhbVtNXT4+XG4gICAgICAgIDogKFxuICAgICAgICAgICAgYXJnczogT3B0czxNPixcbiAgICAgICAgICAgIHNpZ25hbD86IEFib3J0U2lnbmFsLFxuICAgICAgICApID0+IFByb21pc2U8UmV0dXJuVHlwZTxUZWxlZ3JhbVtNXT4+O1xufTtcblxuZXhwb3J0IHR5cGUgUGF5bG9hZDxNIGV4dGVuZHMgTWV0aG9kczxSPiwgUiBleHRlbmRzIFJhd0FwaT4gPSBNIGV4dGVuZHMgdW5rbm93blxuICAgID8gUltNXSBleHRlbmRzIChzaWduYWw/OiBBYm9ydFNpZ25hbCkgPT4gdW5rbm93biAvLyBkZW5vLWxpbnQtaWdub3JlIGJhbi10eXBlc1xuICAgICAgICA/IHt9IC8vIGRlbm8tbGludC1pZ25vcmUgbm8tZXhwbGljaXQtYW55XG4gICAgOiBSW01dIGV4dGVuZHMgKGFyZ3M6IGFueSwgc2lnbmFsPzogQWJvcnRTaWduYWwpID0+IHVua25vd25cbiAgICAgICAgPyBQYXJhbWV0ZXJzPFJbTV0+WzBdXG4gICAgOiBuZXZlclxuICAgIDogbmV2ZXI7XG5cbi8qKlxuICogU21hbGwgdXRpbGl0eSBpbnRlcmZhY2UgdGhhdCBhYnN0cmFjdHMgZnJvbSB3ZWJob29rIHJlcGx5IGNhbGxzIG9mIGRpZmZlcmVudFxuICogd2ViIGZyYW1ld29ya3MuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV2ViaG9va1JlcGx5RW52ZWxvcGUge1xuICAgIHNlbmQ/OiAocGF5bG9hZDogc3RyaW5nKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbn1cblxuLyoqXG4gKiBUeXBlIG9mIGEgZnVuY3Rpb24gdGhhdCBjYW4gcGVyZm9ybSBhbiBBUEkgY2FsbC4gVXNlZCBmb3IgVHJhbnNmb3JtZXJzLlxuICovXG5leHBvcnQgdHlwZSBBcGlDYWxsRm48UiBleHRlbmRzIFJhd0FwaSA9IFJhd0FwaT4gPSA8TSBleHRlbmRzIE1ldGhvZHM8Uj4+KFxuICAgIG1ldGhvZDogTSxcbiAgICBwYXlsb2FkOiBQYXlsb2FkPE0sIFI+LFxuICAgIHNpZ25hbD86IEFib3J0U2lnbmFsLFxuKSA9PiBQcm9taXNlPEFwaVJlc3BvbnNlPEFwaUNhbGxSZXN1bHQ8TSwgUj4+PjtcblxudHlwZSBBcGlDYWxsUmVzdWx0PE0gZXh0ZW5kcyBNZXRob2RzPFI+LCBSIGV4dGVuZHMgUmF3QXBpPiA9IFJbTV0gZXh0ZW5kc1xuICAgICguLi5hcmdzOiB1bmtub3duW10pID0+IHVua25vd24gPyBBd2FpdGVkPFJldHVyblR5cGU8UltNXT4+IDogbmV2ZXI7XG5cbi8qKlxuICogQVBJIGNhbGwgdHJhbnNmb3JtZXJzIGFyZSBmdW5jdGlvbnMgdGhhdCBjYW4gYWNjZXNzIGFuZCBtb2RpZnkgdGhlIG1ldGhvZCBhbmRcbiAqIHBheWxvYWQgb2YgYW4gQVBJIGNhbGwgb24gdGhlIGZseS4gVGhpcyBjYW4gYmUgdXNlZnVsIGlmIHlvdSB3YW50IHRvXG4gKiBpbXBsZW1lbnQgcmF0ZSBsaW1pdGluZyBvciBvdGhlciB0aGluZ3MgYWdhaW5zdCB0aGUgVGVsZWdyYW0gQm90IEFQSS5cbiAqXG4gKiBDb25mZXIgdGhlIGdyYW1tWVxuICogW2RvY3VtZW50YXRpb25dKGh0dHBzOi8vZ3JhbW15LmRldi9hZHZhbmNlZC90cmFuc2Zvcm1lcnMuaHRtbCkgdG8gcmVhZCBtb3JlXG4gKiBhYm91dCBob3cgdG8gdXNlIHRyYW5zZm9ybWVycy5cbiAqL1xuZXhwb3J0IHR5cGUgVHJhbnNmb3JtZXI8UiBleHRlbmRzIFJhd0FwaSA9IFJhd0FwaT4gPSA8TSBleHRlbmRzIE1ldGhvZHM8Uj4+KFxuICAgIHByZXY6IEFwaUNhbGxGbjxSPixcbiAgICBtZXRob2Q6IE0sXG4gICAgcGF5bG9hZDogUGF5bG9hZDxNLCBSPixcbiAgICBzaWduYWw/OiBBYm9ydFNpZ25hbCxcbikgPT4gUHJvbWlzZTxBcGlSZXNwb25zZTxBcGlDYWxsUmVzdWx0PE0sIFI+Pj47XG5leHBvcnQgdHlwZSBUcmFuc2Zvcm1lckNvbnN1bWVyPFIgZXh0ZW5kcyBSYXdBcGkgPSBSYXdBcGk+ID0gVHJhbnNmb3JtYWJsZUFwaTxcbiAgICBSXG4+W1widXNlXCJdO1xuLyoqXG4gKiBBIHRyYW5zZm9ybWFibGUgQVBJIGVuaGFuY2VzIHRoZSBgUmF3QXBpYCB0eXBlIGJ5IHRyYW5zZm9ybWVycy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFuc2Zvcm1hYmxlQXBpPFIgZXh0ZW5kcyBSYXdBcGkgPSBSYXdBcGk+IHtcbiAgICAvKipcbiAgICAgKiBBY2Nlc3MgdG8gdGhlIHJhdyBBUEkgdGhhdCB0aGUgdHJhbnNmb3JtZXJzIHdpbGwgYmUgaW5zdGFsbGVkIG9uLlxuICAgICAqL1xuICAgIHJhdzogUjtcbiAgICAvKipcbiAgICAgKiBDYW4gYmUgdXNlZCB0byByZWdpc3RlciBhbnkgbnVtYmVyIG9mIHRyYW5zZm9ybWVycyBvbiB0aGUgQVBJLlxuICAgICAqL1xuICAgIHVzZTogKC4uLnRyYW5zZm9ybWVyczogVHJhbnNmb3JtZXI8Uj5bXSkgPT4gdGhpcztcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVhZG9ubHkgbGlzdCBvciB0aGUgY3VycmVudGx5IGluc3RhbGxlZCB0cmFuc2Zvcm1lcnMuIFRoZSBsaXN0XG4gICAgICogaXMgc29ydGVkIGJ5IHRpbWUgb2YgaW5zdGFsbGF0aW9uIHdoZXJlIGluZGV4IDAgcmVwcmVzZW50cyB0aGVcbiAgICAgKiB0cmFuc2Zvcm1lciB0aGF0IHdhcyBpbnN0YWxsZWQgZmlyc3QuXG4gICAgICovXG4gICAgaW5zdGFsbGVkVHJhbnNmb3JtZXJzOiBUcmFuc2Zvcm1lcjxSPltdO1xufVxuXG4vLyBUcmFuc2Zvcm1lciBiYXNlIGZ1bmN0aW9uc1xuZnVuY3Rpb24gY29uY2F0VHJhbnNmb3JtZXI8UiBleHRlbmRzIFJhd0FwaT4oXG4gICAgcHJldjogQXBpQ2FsbEZuPFI+LFxuICAgIHRyYW5zOiBUcmFuc2Zvcm1lcjxSPixcbik6IEFwaUNhbGxGbjxSPiB7XG4gICAgcmV0dXJuIChtZXRob2QsIHBheWxvYWQsIHNpZ25hbCkgPT4gdHJhbnMocHJldiwgbWV0aG9kLCBwYXlsb2FkLCBzaWduYWwpO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQVBJIGNsaWVudCB0aGF0IGV2ZW50dWFsbHkgY29ubmVjdHMgdG8gdGhlIFRlbGVncmFtXG4gKiBCb3QgQVBJIHNlcnZlciBhbmQgbWFrZXMgdGhlIEhUVFAgcmVxdWVzdHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXBpQ2xpZW50T3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogUm9vdCBVUkwgb2YgdGhlIFRlbGVncmFtIEJvdCBBUEkgc2VydmVyLiBEZWZhdWx0OlxuICAgICAqIGh0dHBzOi8vYXBpLnRlbGVncmFtLm9yZ1xuICAgICAqL1xuICAgIGFwaVJvb3Q/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdG8gdXNlIHRoZSBbdGVzdFxuICAgICAqIGVudmlyb25tZW50XShodHRwczovL2NvcmUudGVsZWdyYW0ub3JnL2JvdHMvd2ViYXBwcyN1c2luZy1ib3RzLWluLXRoZS10ZXN0LWVudmlyb25tZW50KS5cbiAgICAgKiBDYW4gYmUgZWl0aGVyIGBcInByb2RcImAgKGRlZmF1bHQpIG9yIGBcInRlc3RcImAuXG4gICAgICpcbiAgICAgKiBUaGUgdGVzdGluZyBpbmZyYXN0cnVjdHVyZSBpcyBzZXBhcmF0ZSBmcm9tIHRoZSByZWd1bGFyIHByb2R1Y3Rpb25cbiAgICAgKiBpbmZyYXN0cnVjdHVyZS4gTm8gY2hhdHMsIGFjY291bnRzLCBvciBvdGhlciBkYXRhIGlzIHNoYXJlZCBiZXR3ZWVuIHRoZW0uXG4gICAgICogSWYgeW91IHNldCB0aGlzIG9wdGlvbiB0byBgXCJ0ZXN0XCJgLCB5b3Ugd2lsbCBuZWVkIHRvIG1ha2UgeW91ciBUZWxlZ3JhbVxuICAgICAqIGNsaWVudCBjb25uZWN0IHRvIHRoZSB0ZXN0aW5nIGRhdGEgY2VudGVycyBvZiBUZWxlZ3JhbSwgcmVnaXN0ZXIgeW91clxuICAgICAqIHBob25lIG51bWJlciBhZ2Fpbiwgb3BlbiBhIG5ldyBjaGF0IHdpdGggQEJvdEZhdGhlciwgYW5kIGNyZWF0ZSBhXG4gICAgICogc2VwYXJhdGUgYm90LlxuICAgICAqL1xuICAgIGVudmlyb25tZW50PzogXCJwcm9kXCIgfCBcInRlc3RcIjtcbiAgICAvKipcbiAgICAgKiBVUkwgYnVpbGRlciBmdW5jdGlvbiBmb3IgQVBJIGNhbGxzLiBDYW4gYmUgdXNlZCB0byBtb2RpZnkgd2hpY2ggQVBJXG4gICAgICogc2VydmVyIHNob3VsZCBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vdCBUaGUgVVJMIHRoYXQgd2FzIHBhc3NlZCBpbiBgYXBpUm9vdGAsIG9yIGl0cyBkZWZhdWx0IHZhbHVlXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSBib3QncyB0b2tlbiB0aGF0IHdhcyBwYXNzZWQgd2hlbiBjcmVhdGluZyB0aGUgYm90XG4gICAgICogQHBhcmFtIG1ldGhvZCBUaGUgQVBJIG1ldGhvZCB0byBiZSBjYWxsZWQsIGUuZy4gYGdldE1lYFxuICAgICAqIEBwYXJhbSBlbnYgVGhlIHZhbHVlIHRoYXQgd2FzIHBhc3NlZCBpbiBgZW52aXJvbm1lbnRgLCBvciBpdHMgZGVmYXVsdCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBVUkwgdGhhdCB3aWxsIGJlIGZldGNoZWQgZHVyaW5nIHRoZSBBUEkgY2FsbFxuICAgICAqL1xuICAgIGJ1aWxkVXJsPzogKFxuICAgICAgICByb290OiBzdHJpbmcsXG4gICAgICAgIHRva2VuOiBzdHJpbmcsXG4gICAgICAgIG1ldGhvZDogc3RyaW5nLFxuICAgICAgICBlbnY6IFwicHJvZFwiIHwgXCJ0ZXN0XCIsXG4gICAgKSA9PiBzdHJpbmcgfCBVUkw7XG4gICAgLyoqXG4gICAgICogTWF4aW11bSBudW1iZXIgb2Ygc2Vjb25kcyB0aGF0IGEgcmVxdWVzdCB0byB0aGUgQm90IEFQSSBzZXJ2ZXIgbWF5IHRha2UuXG4gICAgICogSWYgYSByZXF1ZXN0IGhhcyBub3QgY29tcGxldGVkIGJlZm9yZSB0aGlzIHRpbWUgaGFzIGVsYXBzZWQsIGdyYW1tWVxuICAgICAqIGFib3J0cyB0aGUgcmVxdWVzdCBhbmQgZXJyb3JzLiBXaXRob3V0IHN1Y2ggYSB0aW1lb3V0LCBuZXR3b3JraW5nIGlzc3Vlc1xuICAgICAqIG1heSBjYXVzZSB5b3VyIGJvdCB0byBsZWF2ZSBvcGVuIGEgY29ubmVjdGlvbiBpbmRlZmluaXRlbHksIHdoaWNoIG1heVxuICAgICAqIGVmZmVjdGl2ZWx5IG1ha2UgeW91ciBib3QgZnJlZXplLlxuICAgICAqXG4gICAgICogWW91IHByb2JhYmx5IGRvIG5vdCBoYXZlIHRvIGNhcmUgYWJvdXQgdGhpcyBvcHRpb24uIEluIHJhcmUgY2FzZXMsIHlvdVxuICAgICAqIG1heSB3YW50IHRvIGFkanVzdCBpdCBpZiB5b3UgYXJlIHRyYW5zZmVycmluZyBsYXJnZSBmaWxlcyB2aWEgc2xvd1xuICAgICAqIGNvbm5lY3Rpb25zIHRvIHlvdXIgb3duIEJvdCBBUEkgc2VydmVyLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgbnVtYmVyIG9mIHNlY29uZHMgaXMgYDUwMGAsIHdoaWNoIGNvcnJlc3BvbmRzIHRvIDggbWludXRlc1xuICAgICAqIGFuZCAyMCBzZWNvbmRzLiBOb3RlIHRoYXQgdGhpcyBpcyBhbHNvIHRoZSB2YWx1ZSB0aGF0IGlzIGhhcmQtY29kZWQgaW5cbiAgICAgKiB0aGUgb2ZmaWNpYWwgQm90IEFQSSBzZXJ2ZXIsIHNvIHlvdSBjYW5ub3QgcGVyZm9ybSBhbnkgc3VjY2Vzc2Z1bFxuICAgICAqIHJlcXVlc3RzIHRoYXQgZXhjZWVkIHRoaXMgdGltZSBmcmFtZSAoZXZlbiBpZiB5b3Ugd291bGQgYWxsb3cgaXQgaW5cbiAgICAgKiBncmFtbVkpLiBTZXR0aW5nIHRoaXMgb3B0aW9uIHRvIGhpZ2hlciB0aGFuIHRoZSBkZWZhdWx0IG9ubHkgbWFrZXMgc2Vuc2VcbiAgICAgKiB3aXRoIGEgY3VzdG9tIEJvdCBBUEkgc2VydmVyLlxuICAgICAqL1xuICAgIHRpbWVvdXRTZWNvbmRzPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBib3QgaXMgcnVubmluZyBvbiB3ZWJob29rcywgYXMgc29vbiBhcyB0aGUgYm90IHJlY2VpdmVzIGFuIHVwZGF0ZVxuICAgICAqIGZyb20gVGVsZWdyYW0sIGl0IGlzIHBvc3NpYmxlIHRvIG1ha2UgdXAgdG8gb25lIEFQSSBjYWxsIGluIHRoZSByZXNwb25zZVxuICAgICAqIHRvIHRoZSB3ZWJob29rIHJlcXVlc3QuIEFzIGEgYmVuZWZpdCwgdGhpcyBzYXZlcyB5b3VyIGJvdCBmcm9tIG1ha2luZyB1cFxuICAgICAqIHRvIG9uZSBIVFRQIHJlcXVlc3QgcGVyIHVwZGF0ZS4gSG93ZXZlciwgdGhlcmUgYXJlIGEgbnVtYmVyIG9mIGRyYXdiYWNrc1xuICAgICAqIHRvIHVzaW5nIHRoaXM6XG4gICAgICogMSkgWW91IHdpbGwgbm90IGJlIGFibGUgdG8gaGFuZGxlIHBvdGVudGlhbCBlcnJvcnMgb2YgdGhlIHJlc3BlY3RpdmUgQVBJXG4gICAgICogICAgY2FsbC4gVGhpcyBpbmNsdWRlcyByYXRlIGxpbWl0aW5nIGVycm9ycywgc28gc2VudCBtZXNzYWdlcyBjYW4gYmVcbiAgICAgKiAgICBzd2FsbG93ZWQgYnkgdGhlIEJvdCBBUEkgc2VydmVyIGFuZCB0aGVyZSBpcyBubyB3YXkgdG8gZGV0ZWN0IGlmIGFcbiAgICAgKiAgICBtZXNzYWdlIHdhcyBhY3R1YWxseSBzZW50IG9yIG5vdC5cbiAgICAgKiAyKSBNb3JlIGltcG9ydGFudGx5LCB5b3UgYWxzbyB3b24ndCBoYXZlIGFjY2VzcyB0byB0aGUgcmVzcG9uc2Ugb2JqZWN0LFxuICAgICAqICAgIHNvIGUuZy4gY2FsbGluZyBgc2VuZE1lc3NhZ2VgIHdpbGwgbm90IGdpdmUgeW91IGFjY2VzcyB0byB0aGUgbWVzc2FnZVxuICAgICAqICAgIHlvdSBzZW50LlxuICAgICAqIDMpIEZ1cnRoZXJtb3JlLCBpdCBpcyBub3QgcG9zc2libGUgdG8gY2FuY2VsIHRoZSByZXF1ZXN0LiBUaGVcbiAgICAgKiAgICBgQWJvcnRTaWduYWxgIHdpbGwgYmUgZGlzcmVnYXJkZWQuXG4gICAgICogNCkgTm90ZSBhbHNvIHRoYXQgdGhlIHR5cGVzIGluIGdyYW1tWSBkbyBub3QgcmVmbGVjdCB0aGUgY29uc2VxdWVuY2VzIG9mXG4gICAgICogICAgYSBwZXJmb3JtZWQgd2ViaG9vayBjYWxsYmFjayEgRm9yIGluc3RhbmNlLCB0aGV5IGluZGljYXRlIHRoYXQgeW91XG4gICAgICogICAgYWx3YXlzIHJlY2VpdmUgYSByZXNwb25zZSBvYmplY3QsIHNvIGl0IGlzIHlvdXIgb3duIHJlc3BvbnNpYmlsaXR5IHRvXG4gICAgICogICAgbWFrZSBzdXJlIHlvdSdyZSBub3Qgc2NyZXdpbmcgdXAgd2hpbGUgdXNpbmcgdGhpcyBtaW5vciBwZXJmb3JtYW5jZVxuICAgICAqICAgIG9wdGltaXphdGlvbi5cbiAgICAgKlxuICAgICAqIFdpdGggdGhpcyB3YXJuaW5nIG91dCBvZiB0aGUgd2F5LCBoZXJlIGlzIHdoYXQgeW91IGNhbiBkbyB3aXRoIHRoZVxuICAgICAqIGBjYW5Vc2VXZWJob29rUmVwbHlgIG9wdGlvbjogaXQgY2FuIGJlIHVzZWQgdG8gcGFzcyBhIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiBkZXRlcm1pbmVzIHdoZXRoZXIgdG8gdXNlIHdlYmhvb2sgcmVwbHkgZm9yIHRoZSBnaXZlbiBtZXRob2QuIEl0IHdpbGxcbiAgICAgKiBvbmx5IGJlIGludm9rZWQgaWYgdGhlIHBheWxvYWQgY2FuIGJlIHNlbnQgYXMgSlNPTi4gSXQgd2lsbCBub3QgYmVcbiAgICAgKiBpbnZva2VkIGFnYWluIGZvciBhIGdpdmVuIHVwZGF0ZSBhZnRlciBpdCByZXR1cm5lZCBgdHJ1ZWAsIGluZGljYXRpbmdcbiAgICAgKiB0aGF0IHRoZSBBUEkgY2FsbCBzaG91bGQgYmUgcGVyZm9ybWVkIGFzIGEgd2ViaG9vayBzZW5kLiBJbiBvdGhlciB3b3JkcyxcbiAgICAgKiBzdWJzZXF1ZW50IEFQSSBjYWxscyAoZHVyaW5nIHRoZSBzYW1lIHVwZGF0ZSkgd2lsbCBhbHdheXMgcGVyZm9ybSB0aGVpclxuICAgICAqIG93biBIVFRQIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldGhvZCBUaGUgbWV0aG9kIHRvIGNhbGxcbiAgICAgKi9cbiAgICBjYW5Vc2VXZWJob29rUmVwbHk/OiAobWV0aG9kOiBzdHJpbmcpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQmFzZSBjb25maWd1cmF0aW9uIGZvciBgZmV0Y2hgIGNhbGxzLiBTcGVjaWZ5IGFueSBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiB0byB1c2Ugd2hlbiBmZXRjaGluZyBhIG1ldGhvZCBvZiB0aGUgVGVsZWdyYW0gQm90IEFQSS4gRGVmYXVsdDogYHtcbiAgICAgKiBjb21wcmVzczogdHJ1ZSB9YCAoTm9kZSksIGB7fWAgKERlbm8pXG4gICAgICovXG4gICAgYmFzZUZldGNoQ29uZmlnPzogT21pdDxcbiAgICAgICAgTm9uTnVsbGFibGU8UGFyYW1ldGVyczx0eXBlb2YgZmV0Y2g+WzFdPixcbiAgICAgICAgXCJtZXRob2RcIiB8IFwiaGVhZGVyc1wiIHwgXCJib2R5XCJcbiAgICA+O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIG5ldHdvcmsgY29ubmVjdGlvbiBpcyB1bnJlbGlhYmxlIGFuZCBzb21lIEFQSSByZXF1ZXN0cyBmYWlsXG4gICAgICogYmVjYXVzZSBvZiB0aGF0LCBncmFtbVkgd2lsbCB0aHJvdyBlcnJvcnMgdGhhdCB0ZWxsIHlvdSBleGFjdGx5IHdoaWNoXG4gICAgICogcmVxdWVzdHMgZmFpbGVkLiBIb3dldmVyLCB0aGUgZXJyb3IgbWVzc2FnZXMgZG8gbm90IGRpc2Nsb3NlIHRoZSBmZXRjaGVkXG4gICAgICogVVJMIGFzIGl0IGNvbnRhaW5zIHlvdXIgYm90J3MgdG9rZW4uIExvZ2dpbmcgaXQgbWF5IGxlYWQgdG8gdG9rZW4gbGVha3MuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgYXJlIHN1cmUgdGhhdCBubyBsb2dzIGFyZSBldmVyIHBvc3RlZCBpbiBUZWxlZ3JhbSBjaGF0cywgR2l0SHViXG4gICAgICogaXNzdWVzLCBvciBvdGhlcndpc2Ugc2hhcmVkLCB5b3UgY2FuIHNldCB0aGlzIG9wdGlvbiB0byBgdHJ1ZWAgaW4gb3JkZXJcbiAgICAgKiB0byBvYnRhaW4gbW9yZSBkZXRhaWxlZCBsb2dzIHRoYXQgbWF5IGhlbHAgeW91IGRlYnVnIHlvdXIgYm90LiBUaGVcbiAgICAgKiBkZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAsIG1lYW5pbmcgdGhhdCB0aGUgYm90IHRva2VuIGlzIG5vdCBsb2dnZWQuXG4gICAgICovXG4gICAgc2Vuc2l0aXZlTG9ncz86IGJvb2xlYW47XG59XG5cbmNsYXNzIEFwaUNsaWVudDxSIGV4dGVuZHMgUmF3QXBpPiB7XG4gICAgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBSZXF1aXJlZDxBcGlDbGllbnRPcHRpb25zPjtcblxuICAgIHByaXZhdGUgaGFzVXNlZFdlYmhvb2tSZXBseSA9IGZhbHNlO1xuXG4gICAgcmVhZG9ubHkgaW5zdGFsbGVkVHJhbnNmb3JtZXJzOiBUcmFuc2Zvcm1lcjxSPltdID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSB0b2tlbjogc3RyaW5nLFxuICAgICAgICBvcHRpb25zOiBBcGlDbGllbnRPcHRpb25zID0ge30sXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgd2ViaG9va1JlcGx5RW52ZWxvcGU6IFdlYmhvb2tSZXBseUVudmVsb3BlID0ge30sXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGFwaVJvb3QgPSBvcHRpb25zLmFwaVJvb3QgPz8gXCJodHRwczovL2FwaS50ZWxlZ3JhbS5vcmdcIjtcbiAgICAgICAgY29uc3QgZW52aXJvbm1lbnQgPSBvcHRpb25zLmVudmlyb25tZW50ID8/IFwicHJvZFwiO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhcGlSb290LFxuICAgICAgICAgICAgZW52aXJvbm1lbnQsXG4gICAgICAgICAgICBidWlsZFVybDogb3B0aW9ucy5idWlsZFVybCA/PyBkZWZhdWx0QnVpbGRVcmwsXG4gICAgICAgICAgICB0aW1lb3V0U2Vjb25kczogb3B0aW9ucy50aW1lb3V0U2Vjb25kcyA/PyA1MDAsXG4gICAgICAgICAgICBiYXNlRmV0Y2hDb25maWc6IHtcbiAgICAgICAgICAgICAgICAuLi5iYXNlRmV0Y2hDb25maWcoYXBpUm9vdCksXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5iYXNlRmV0Y2hDb25maWcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuVXNlV2ViaG9va1JlcGx5OiBvcHRpb25zLmNhblVzZVdlYmhvb2tSZXBseSA/PyAoKCkgPT4gZmFsc2UpLFxuICAgICAgICAgICAgc2Vuc2l0aXZlTG9nczogb3B0aW9ucy5zZW5zaXRpdmVMb2dzID8/IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFwaVJvb3QuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYFJlbW92ZSB0aGUgdHJhaWxpbmcgJy8nIGZyb20gdGhlICdhcGlSb290JyBvcHRpb24gKHVzZSAnJHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFwaVJvb3Quc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hcGlSb290Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9JyBpbnN0ZWFkIG9mICcke3RoaXMub3B0aW9ucy5hcGlSb290fScpYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNhbGw6IEFwaUNhbGxGbjxSPiA9IGFzeW5jIDxNIGV4dGVuZHMgTWV0aG9kczxSPj4oXG4gICAgICAgIG1ldGhvZDogTSxcbiAgICAgICAgcDogUGF5bG9hZDxNLCBSPixcbiAgICAgICAgc2lnbmFsPzogQWJvcnRTaWduYWwsXG4gICAgKSA9PiB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBwID8/IHt9O1xuICAgICAgICBkZWJ1ZyhgQ2FsbGluZyAke21ldGhvZH1gKTtcbiAgICAgICAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB2YWxpZGF0ZVNpZ25hbChtZXRob2QsIHBheWxvYWQsIHNpZ25hbCk7XG4gICAgICAgIC8vIEdlbmVyYWwgY29uZmlnXG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhUmVxdWlyZWQgPSByZXF1aXJlc0Zvcm1EYXRhVXBsb2FkKHBheWxvYWQpO1xuICAgICAgICAvLyBTaG9ydC1jaXJjdWl0IG9uIHdlYmhvb2sgcmVwbHlcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy53ZWJob29rUmVwbHlFbnZlbG9wZS5zZW5kICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICF0aGlzLmhhc1VzZWRXZWJob29rUmVwbHkgJiZcbiAgICAgICAgICAgICFmb3JtRGF0YVJlcXVpcmVkICYmXG4gICAgICAgICAgICBvcHRzLmNhblVzZVdlYmhvb2tSZXBseShtZXRob2QpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5oYXNVc2VkV2ViaG9va1JlcGx5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGNyZWF0ZUpzb25QYXlsb2FkKHsgLi4ucGF5bG9hZCwgbWV0aG9kIH0pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy53ZWJob29rUmVwbHlFbnZlbG9wZS5zZW5kKGNvbmZpZy5ib2R5KTtcbiAgICAgICAgICAgIHJldHVybiB7IG9rOiB0cnVlLCByZXN1bHQ6IHRydWUgYXMgQXBpQ2FsbFJlc3VsdDxNLCBSPiB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSB0aW1lb3V0cyBhbmQgZXJyb3JzIGluIHRoZSB1bmRlcmx5aW5nIGZvcm0tZGF0YSBzdHJlYW1cbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlckZyb21TaWduYWwoc2lnbmFsKTtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IGNyZWF0ZVRpbWVvdXQoY29udHJvbGxlciwgb3B0cy50aW1lb3V0U2Vjb25kcywgbWV0aG9kKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtRXJyID0gY3JlYXRlU3RyZWFtRXJyb3IoY29udHJvbGxlcik7XG4gICAgICAgIC8vIEJ1aWxkIHJlcXVlc3QgVVJMIGFuZCBjb25maWdcbiAgICAgICAgY29uc3QgdXJsID0gb3B0cy5idWlsZFVybChcbiAgICAgICAgICAgIG9wdHMuYXBpUm9vdCxcbiAgICAgICAgICAgIHRoaXMudG9rZW4sXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBvcHRzLmVudmlyb25tZW50LFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBjb25maWcgPSBmb3JtRGF0YVJlcXVpcmVkXG4gICAgICAgICAgICA/IGNyZWF0ZUZvcm1EYXRhUGF5bG9hZChwYXlsb2FkLCAoZXJyKSA9PiBzdHJlYW1FcnIuY2F0Y2goZXJyKSlcbiAgICAgICAgICAgIDogY3JlYXRlSnNvblBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgIGNvbnN0IHNpZyA9IGNvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICBjb25zdCBvcHRpb25zID0geyAuLi5vcHRzLmJhc2VGZXRjaENvbmZpZywgc2lnbmFsOiBzaWcsIC4uLmNvbmZpZyB9O1xuICAgICAgICAvLyBQZXJmb3JtIGZldGNoIGNhbGwsIGFuZCBoYW5kbGUgbmV0d29ya2luZyBlcnJvcnNcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1Byb21pc2UgPSBmZXRjaChcbiAgICAgICAgICAgIHVybCBpbnN0YW5jZW9mIFVSTCA/IHVybC5ocmVmIDogdXJsLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgKS5jYXRjaCh0b0h0dHBFcnJvcihtZXRob2QsIG9wdHMuc2Vuc2l0aXZlTG9ncykpO1xuICAgICAgICAvLyBUaG9zZSBhcmUgdGhlIHRocmVlIHBvc3NpYmxlIG91dGNvbWVzIG9mIHRoZSBmZXRjaCBjYWxsOlxuICAgICAgICBjb25zdCBvcGVyYXRpb25zID0gW3N1Y2Nlc3NQcm9taXNlLCBzdHJlYW1FcnIucHJvbWlzZSwgdGltZW91dC5wcm9taXNlXTtcbiAgICAgICAgLy8gV2FpdCBmb3IgcmVzdWx0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLnJhY2Uob3BlcmF0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0LmhhbmRsZSAhPT0gdW5kZWZpbmVkKSBjbGVhclRpbWVvdXQodGltZW91dC5oYW5kbGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHVzZSguLi50cmFuc2Zvcm1lcnM6IFRyYW5zZm9ybWVyPFI+W10pIHtcbiAgICAgICAgdGhpcy5jYWxsID0gdHJhbnNmb3JtZXJzLnJlZHVjZShjb25jYXRUcmFuc2Zvcm1lciwgdGhpcy5jYWxsKTtcbiAgICAgICAgdGhpcy5pbnN0YWxsZWRUcmFuc2Zvcm1lcnMucHVzaCguLi50cmFuc2Zvcm1lcnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBhc3luYyBjYWxsQXBpPE0gZXh0ZW5kcyBNZXRob2RzPFI+PihcbiAgICAgICAgbWV0aG9kOiBNLFxuICAgICAgICBwYXlsb2FkOiBQYXlsb2FkPE0sIFI+LFxuICAgICAgICBzaWduYWw/OiBBYm9ydFNpZ25hbCxcbiAgICApIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2FsbChtZXRob2QsIHBheWxvYWQsIHNpZ25hbCk7XG4gICAgICAgIGlmIChkYXRhLm9rKSByZXR1cm4gZGF0YS5yZXN1bHQ7XG4gICAgICAgIGVsc2UgdGhyb3cgdG9HcmFtbXlFcnJvcihkYXRhLCBtZXRob2QsIHBheWxvYWQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRyYW5zZm9ybWFibGUgQVBJLCBpLmUuIGFuIG9iamVjdCB0aGF0IGxldHMgeW91IHBlcmZvcm0gcmF3IEFQSVxuICogY2FsbHMgdG8gdGhlIFRlbGVncmFtIEJvdCBBUEkgc2VydmVyIGJ1dCBwYXNzIHRoZSBjYWxscyB0aHJvdWdoIGEgc3RhY2sgb2ZcbiAqIHRyYW5zZm9ybWVycyBiZWZvcmUuIFRoaXMgd2lsbCBjcmVhdGUgYSBuZXcgQVBJIGNsaWVudCBpbnN0YW5jZSB1bmRlciB0aGVcbiAqIGhvb2QgdGhhdCB3aWxsIGJlIHVzZWQgdG8gY29ubmVjdCB0byB0aGUgVGVsZWdyYW0gc2VydmVycy4gWW91IHRoZXJlZm9yZSBuZWVkXG4gKiB0byBwYXNzIHRoZSBib3QgdG9rZW4uIEluIGFkZGl0aW9uLCB5b3UgbWF5IHBhc3MgQVBJIGNsaWVudCBvcHRpb25zIGFzIHdlbGxcbiAqIGFzIGEgd2ViaG9vayByZXBseSBlbnZlbG9wZSB0aGF0IGFsbG93cyB0aGUgY2xpZW50IHRvIHBlcmZvcm0gdXAgdG8gb25lIEhUVFBcbiAqIHJlcXVlc3QgaW4gcmVzcG9uc2UgdG8gYSB3ZWJob29rIGNhbGwgaWYgdGhpcyBpcyBkZXNpcmVkLlxuICpcbiAqIEBwYXJhbSB0b2tlbiBUaGUgYm90J3MgdG9rZW5cbiAqIEBwYXJhbSBvcHRpb25zIEEgbnVtYmVyIG9mIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgY3JlYXRlZCBBUEkgY2xpZW50XG4gKiBAcGFyYW0gd2ViaG9va1JlcGx5RW52ZWxvcGUgVGhlIHdlYmhvb2sgcmVwbHkgZW52ZWxvcGUgdGhhdCB3aWxsIGJlIHVzZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJhd0FwaTxSIGV4dGVuZHMgUmF3QXBpPihcbiAgICB0b2tlbjogc3RyaW5nLFxuICAgIG9wdGlvbnM/OiBBcGlDbGllbnRPcHRpb25zLFxuICAgIHdlYmhvb2tSZXBseUVudmVsb3BlPzogV2ViaG9va1JlcGx5RW52ZWxvcGUsXG4pOiBUcmFuc2Zvcm1hYmxlQXBpPFI+IHtcbiAgICBjb25zdCBjbGllbnQgPSBuZXcgQXBpQ2xpZW50PFI+KHRva2VuLCBvcHRpb25zLCB3ZWJob29rUmVwbHlFbnZlbG9wZSk7XG5cbiAgICBjb25zdCBwcm94eUhhbmRsZXI6IFByb3h5SGFuZGxlcjxSPiA9IHtcbiAgICAgICAgZ2V0KF8sIG06IE1ldGhvZHM8Uj4gfCBcInRvSlNPTlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbSA9PT0gXCJ0b0pTT05cIlxuICAgICAgICAgICAgICAgID8gXCJfX2ludGVybmFsXCJcbiAgICAgICAgICAgICAgICA6IGNsaWVudC5jYWxsQXBpLmJpbmQoY2xpZW50LCBtKTtcbiAgICAgICAgfSxcbiAgICAgICAgLi4ucHJveHlNZXRob2RzLFxuICAgIH07XG4gICAgY29uc3QgcmF3ID0gbmV3IFByb3h5KHt9IGFzIFIsIHByb3h5SGFuZGxlcik7XG4gICAgY29uc3QgaW5zdGFsbGVkVHJhbnNmb3JtZXJzID0gY2xpZW50Lmluc3RhbGxlZFRyYW5zZm9ybWVycztcbiAgICBjb25zdCBhcGk6IFRyYW5zZm9ybWFibGVBcGk8Uj4gPSB7XG4gICAgICAgIHJhdyxcbiAgICAgICAgaW5zdGFsbGVkVHJhbnNmb3JtZXJzLFxuICAgICAgICB1c2U6ICguLi50KSA9PiB7XG4gICAgICAgICAgICBjbGllbnQudXNlKC4uLnQpO1xuICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGFwaTtcbn1cblxuY29uc3QgZGVmYXVsdEJ1aWxkVXJsOiBOb25OdWxsYWJsZTxBcGlDbGllbnRPcHRpb25zW1wiYnVpbGRVcmxcIl0+ID0gKFxuICAgIHJvb3QsXG4gICAgdG9rZW4sXG4gICAgbWV0aG9kLFxuICAgIGVudixcbikgPT4ge1xuICAgIGNvbnN0IHByZWZpeCA9IGVudiA9PT0gXCJ0ZXN0XCIgPyBcInRlc3QvXCIgOiBcIlwiO1xuICAgIHJldHVybiBgJHtyb290fS9ib3Qke3Rva2VufS8ke3ByZWZpeH0ke21ldGhvZH1gO1xufTtcblxuY29uc3QgcHJveHlNZXRob2RzID0ge1xuICAgIHNldCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgZGVmaW5lUHJvcGVydHkoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGRlbGV0ZVByb3BlcnR5KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBvd25LZXlzKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfSxcbn07XG5cbi8qKiBBIGNvbnRhaW5lciBmb3IgYSByZWplY3RpbmcgcHJvbWlzZSAqL1xuaW50ZXJmYWNlIEFzeW5jRXJyb3Ige1xuICAgIHByb21pc2U6IFByb21pc2U8bmV2ZXI+O1xufVxuLyoqIEFuIGFzeW5jIGVycm9yIGNhdXNlZCBieSBhIHRpbWVvdXQgKi9cbmludGVyZmFjZSBUaW1lb3V0IGV4dGVuZHMgQXN5bmNFcnJvciB7XG4gICAgaGFuZGxlOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZDtcbn1cbi8qKiBBbiBhc3luYyBlcnJvciBjYXVzZWQgYnkgYW4gZXJyb3IgaW4gYW4gdW5kZXJseWluZyByZXNvdXJjZSBzdHJlYW0gKi9cbmludGVyZmFjZSBTdHJlYW1FcnJvciBleHRlbmRzIEFzeW5jRXJyb3Ige1xuICAgIGNhdGNoOiAoZXJyOiB1bmtub3duKSA9PiB2b2lkO1xufVxuXG4vKiogQ3JlYXRlcyBhIHRpbWVvdXQgZXJyb3Igd2hpY2ggYWJvcnRzIGEgZ2l2ZW4gY29udHJvbGxlciAqL1xuZnVuY3Rpb24gY3JlYXRlVGltZW91dChcbiAgICBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsXG4gICAgc2Vjb25kczogbnVtYmVyLFxuICAgIG1ldGhvZDogc3RyaW5nLFxuKTogVGltZW91dCB7XG4gICAgbGV0IGhhbmRsZTogVGltZW91dFtcImhhbmRsZVwiXSA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8bmV2ZXI+KChfLCByZWplY3QpID0+IHtcbiAgICAgICAgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPVxuICAgICAgICAgICAgICAgIGBSZXF1ZXN0IHRvICcke21ldGhvZH0nIHRpbWVkIG91dCBhZnRlciAke3NlY29uZHN9IHNlY29uZHNgO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihtc2cpKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfSwgMTAwMCAqIHNlY29uZHMpO1xuICAgIH0pO1xuICAgIHJldHVybiB7IHByb21pc2UsIGhhbmRsZSB9O1xufVxuLyoqIENyZWF0ZXMgYSBzdHJlYW0gZXJyb3Igd2hpY2ggYWJvcnQgYSBnaXZlbiBjb250cm9sbGVyICovXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1FcnJvcihhYm9ydENvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcik6IFN0cmVhbUVycm9yIHtcbiAgICBsZXQgb25FcnJvcjogU3RyZWFtRXJyb3JbXCJjYXRjaFwiXSA9IChlcnIpID0+IHtcbiAgICAgICAgLy8gUmUtdGhyb3cgYnkgZGVmYXVsdCwgYnV0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gaW1tZWRpYXRlbHlcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH07XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPG5ldmVyPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgIG9uRXJyb3IgPSAoZXJyOiB1bmtub3duKSA9PiB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7IHByb21pc2UsIGNhdGNoOiBvbkVycm9yIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFib3J0Q29udHJvbGxlckZyb21TaWduYWwoc2lnbmFsPzogQWJvcnRTaWduYWwpIHtcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgaWYgKHNpZ25hbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gYWJvcnRDb250cm9sbGVyO1xuICAgIGNvbnN0IHNpZyA9IHNpZ25hbDtcbiAgICBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIHNpZy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnQpO1xuICAgIH1cbiAgICBpZiAoc2lnLmFib3J0ZWQpIGFib3J0KCk7XG4gICAgZWxzZSBzaWcuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0KTtcbiAgICByZXR1cm4geyBhYm9ydCwgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU2lnbmFsKFxuICAgIG1ldGhvZDogc3RyaW5nLFxuICAgIHBheWxvYWQ6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgIHNpZ25hbDogQWJvcnRTaWduYWwsXG4pIHtcbiAgICAvLyBXZSB1c2UgYSB2ZXJ5IHNpbXBsZSBoZXVyaXN0aWMgdG8gY2hlY2sgZm9yIEFib3J0U2lnbmFsIGluc3RhbmNlc1xuICAgIC8vIGluIG9yZGVyIHRvIGF2b2lkIGRvaW5nIGEgcnVudGltZS1zcGVjaWZpYyB2ZXJzaW9uIG9mIGBpbnN0YW5jZW9mYC5cbiAgICBpZiAodHlwZW9mIHNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcGF5bG9hZDAgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICBpZiAocGF5bG9hZDAubGVuZ3RoID4gMjApIHtcbiAgICAgICAgcGF5bG9hZDAgPSBwYXlsb2FkMC5zdWJzdHJpbmcoMCwgMTYpICsgXCIgLi4uXCI7XG4gICAgfVxuICAgIGxldCBwYXlsb2FkMSA9IEpTT04uc3RyaW5naWZ5KHNpZ25hbCk7XG4gICAgaWYgKHBheWxvYWQxLmxlbmd0aCA+IDIwKSB7XG4gICAgICAgIHBheWxvYWQxID0gcGF5bG9hZDEuc3Vic3RyaW5nKDAsIDE2KSArIFwiIC4uLlwiO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbmNvcnJlY3QgYWJvcnQgc2lnbmFsIGluc3RhbmNlIGZvdW5kISBcXFxuWW91IHBhc3NlZCB0d28gcGF5bG9hZHMgdG8gJyR7bWV0aG9kfScgYnV0IHlvdSBzaG91bGQgbWVyZ2UgXFxcbnRoZSBzZWNvbmQgb25lIGNvbnRhaW5pbmcgJyR7cGF5bG9hZDF9JyBpbnRvIHRoZSBmaXJzdCBvbmUgXFxcbmNvbnRhaW5pbmcgJyR7cGF5bG9hZDB9JyEgSWYgeW91IGFyZSB1c2luZyBjb250ZXh0IHNob3J0Y3V0cywgXFxcbnlvdSBtYXkgd2FudCB0byB1c2UgYSBtZXRob2Qgb24gJ2N0eC5hcGknIGluc3RlYWQuXG5cbklmIHlvdSB3YW50IHRvIHByZXZlbnQgc3VjaCBtaXN0YWtlcyBpbiB0aGUgZnV0dXJlLCBcXFxuY29uc2lkZXIgdXNpbmcgVHlwZVNjcmlwdC4gaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2AsXG4gICAgKTtcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLGVBQWUsRUFBRSxTQUFTLENBQUMsUUFBUSxzQkFBc0I7QUFNbEUsU0FBUyxhQUFhLEVBQUUsV0FBVyxRQUFRLGFB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